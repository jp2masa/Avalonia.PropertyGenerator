using System;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

using Avalonia.PropertyGenerator.CSharp.Visitors;

namespace Avalonia.PropertyGenerator.CSharp
{
    [Generator]
    internal sealed class AvaloniaToClrPropertyGenerator : IIncrementalGenerator
    {
        private static readonly string s_generatorName =
            typeof(AvaloniaToClrPropertyGenerator).FullName!;

        private static readonly string s_generatorVersion =
            Assembly.GetExecutingAssembly().GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion;

        public void Initialize(IncrementalGeneratorInitializationContext context) =>
            context.RegisterSourceOutput(
                context.CompilationProvider.Combine(context.ParseOptionsProvider),
                static (ctx, args) => Execute(ctx, args.Left, args.Right)
            );

        private static void Execute(SourceProductionContext context, Compilation compilation, ParseOptions parseOptions)
        {
            if (Types.FromCompilation(compilation, context.ReportDiagnostic) is not { } wellKnownTypes)
            {
                return;
            }

            var attributes =
$@"{AutoGeneratedFileHeader}
namespace Avalonia.PropertyGenerator
{{
    /// <summary>
    /// Copied from roslyn: https://github.com/dotnet/roslyn/blob/9007fbc80c19cef52defe1cfb981c838b995c74d/src/Compilers/Core/Portable/Symbols/Accessibility.cs
    /// </summary>
    {GeneratedCodeAttribute}
    internal enum BackingFieldAccessibility
    {{
        NotApplicable = 0,
        Private = 1,
        ProtectedAndInternal = 2,
        ProtectedAndFriend = ProtectedAndInternal,
        Protected = 3,
        Internal = 4,
        Friend = Internal,
        ProtectedOrInternal = 5,
        ProtectedOrFriend = ProtectedOrInternal,
        Public = 6,
    }}

    {GeneratedCodeAttribute}
    {ExcludeFromCodeCoverageAttribute}
    [global::System.AttributeUsage(global::System.AttributeTargets.Field)]
    internal sealed class BackingFieldAttribute : global::System.Attribute
    {{
        public string? Name {{ get; set; }}

        public global::Avalonia.PropertyGenerator.BackingFieldAccessibility Accessibility {{ get; set; }}
    }}

    {GeneratedCodeAttribute}
    {ExcludeFromCodeCoverageAttribute}
    [global::System.AttributeUsage(global::System.AttributeTargets.Field)]
    internal sealed class ReadonlyAttribute : global::System.Attribute
    {{
    }}
}}
";

            var attributesSource = SourceText.From(attributes, Encoding.UTF8);

            if (parseOptions is not CSharpParseOptions csParseOptions)
            {
                throw new InvalidOperationException("Only C# is currently supported!");
            }

            compilation = compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(attributesSource, csParseOptions));

            var visitor = new AvaloniaPropertyRootVisitor(wellKnownTypes);
            var types = visitor.Visit(compilation.Assembly.GlobalNamespace);

            if (!types.HasValue || types.Value.Length == 0)
            {
                return;
            }

            context.AddSource("Attributes.cs", attributesSource);

            foreach (var type in types)
            {
                var sourceBuilder = new StringBuilder(
$@"{AutoGeneratedFileHeader}
namespace {type.Type.ContainingNamespace.ToDisplayString()}
{{");

                sourceBuilder.Append($@"
    partial class {type.Type.Name}
    {{");

                foreach (var property in type.StyledProperties)
                {

                    if (!property.ClrPropertyExists)
                    {
                        var typeFullName = TypeToFullDisplayString(((INamedTypeSymbol)property.Field.Type).TypeArguments[0]);
                        var accessibility = GetAccessibilityText(property.ClrPropertyAccessibility);

                        sourceBuilder.Append($@"
        {GeneratedCodeAttribute}
        {ExcludeFromCodeCoverageAttribute}
        {accessibility}{typeFullName} {property.Name}
        {{
            get => GetValue({property.Field.Name});
            set => SetValue({property.Field.Name}, value);
        }}
");
                    }
                }

                foreach (var property in type.DirectProperties)
                {
                    var typeFullName = TypeToFullDisplayString(((INamedTypeSymbol)property.Field.Type).TypeArguments[1]);

                    var propertyAccessibility = GetAccessibilityText(property.ClrPropertyAccessibility);
                    var fieldAccessibility = GetAccessibilityText(property.BackingFieldAccessibility);

                    var isReadonly = property.IsReadonly;

                    if (!property.BackingFieldExists)
                    {
                        sourceBuilder.Append($@"
        {GeneratedCodeAttribute}
        {fieldAccessibility}{typeFullName} {property.BackingFieldName};
");
                    }

                    if (!property.ClrPropertyExists)
                    {
                        if (isReadonly)
                        {
                            sourceBuilder.Append($@"
        {GeneratedCodeAttribute}
        {ExcludeFromCodeCoverageAttribute}
        {propertyAccessibility}{typeFullName} {property.Name} => {property.BackingFieldName};
");
                        }
                        else
                        {
                            sourceBuilder.Append($@"
        {GeneratedCodeAttribute}
        {ExcludeFromCodeCoverageAttribute}
        {propertyAccessibility}{typeFullName} {property.Name}
        {{
            get => {property.BackingFieldName};
            set => SetAndRaise({property.Field.Name}, ref {property.BackingFieldName}, value);
        }}
");
                        }
                    }
                }

                foreach (var property in type.AttachedProperties)
                {
                    var typeFullName = TypeToFullDisplayString(((INamedTypeSymbol)property.Field.Type).TypeArguments[0]);

                    var getterAccessibility = GetAccessibilityText(property.GetterAccessibility);
                    var setterAccessibility = GetAccessibilityText(property.SetterAccessibility);

                    if (!property.GetterExists)
                    {
                        sourceBuilder.Append($@"
        {GeneratedCodeAttribute}
        {ExcludeFromCodeCoverageAttribute}
        {getterAccessibility}static {typeFullName} Get{property.Name}({TypeToFullDisplayString(wellKnownTypes.AvaloniaObject)} obj) =>
            (obj ?? throw new global::System.ArgumentNullException(nameof(obj))).GetValue({property.Field.Name});
");
                    }

                    if (!property.SetterExists)
                    {
                        sourceBuilder.Append($@"
        {GeneratedCodeAttribute}
        {ExcludeFromCodeCoverageAttribute}
        {setterAccessibility}static void Set{property.Name}({TypeToFullDisplayString(wellKnownTypes.AvaloniaObject)} obj, {typeFullName} value) =>
            (obj ?? throw new global::System.ArgumentNullException(nameof(obj))).SetValue({property.Field.Name}, value);
");
                    }
                }

                sourceBuilder.Append(
@"    }
}
");

                var fileName = FormattableString.Invariant($"{type.Type.ToDisplayString()}.g.cs");
                var sourceText = SourceText.From(sourceBuilder.ToString(), Encoding.UTF8);

                context.AddSource(fileName, sourceText);
            }
        }

        private static string GetAccessibilityText(Accessibility accessibility)
        {
            var result = SyntaxFacts.GetText(accessibility);

            if (!String.IsNullOrWhiteSpace(result))
            {
                result += ' ';
            }

            return result;
        }

        private static string TypeToFullDisplayString(ITypeSymbol type) =>
            type.ToDisplayString(
                SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(
                    SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers
                        | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier
                        | SymbolDisplayMiscellaneousOptions.UseSpecialTypes
                )
            );

        private static string AutoGeneratedFileHeader =>
@"// <auto-generated/>
#pragma warning disable
";

        private static string GeneratedCodeAttribute =>
            $@"[global::System.CodeDom.Compiler.GeneratedCode(""{s_generatorName}"", ""{s_generatorVersion}"")]";

        private static string ExcludeFromCodeCoverageAttribute =>
            "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]";
    }
}
